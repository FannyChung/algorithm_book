## 判断是否回文链表

回文的定义是从左往右和从右往左读是一样的。

### 方法1：利用栈

思路：

1. 先遍历一遍链表，一一把节点值加入栈中。

2. 再遍历一次节点，和弹出的栈顶值比较，如果都相同，则是回文的。

空间：O\(N\)，时间O\(2\*N\)=O\(N\)

### 方法2：利用栈+对称

思路：

1. 先遍历一遍链表，得到链表大小N。

2. 再遍历一遍链表，把前N/2个值放入栈中。

3. 如果N为奇数，则跳过中间这个。

4. 然后把弹出的栈顶值和接着遍历链表的值比较。

空间：O\(N/2\)=O\(N\)，时间O\(2\*N\)=O\(N\)

### 方法3：双指针+逆序后半边链表

思路：



1. 快慢两个指针，慢指针q每次走一步，快指针p每次走两步。如果N是奇数，则p走到终点时，q走到第N/2+1个点（正中间\);如果N是偶数，则p走到倒数第二个点时，q在N/2的位置（中间偏左），接下来p再走一步到终点。



```java
p=q=head;
while(p.next!=null&&p.next.next!=null){
q=q.next;
p=p.next.next;
}
if(p.next!=null){
p=p.next;
}
```



1. 逆转后半段链表。需要3个指针。代码如下：



```java
cur=q;
nxt=cur.next;
//注意后半段的起点变终点，需要把它的next置位空
q.next=null;
while(nxt!=null){
   nnxt=nxt.next;

   //逆转关系

   nxt.next=cur;

   //向下走

   cur=nxt;

   nxt=nnxt;
}
```



比较前半段和逆转的后半段，直到n1走到p（正中间或者中间偏左）为止。



时间：O\(N\)，空间O\(1\)

