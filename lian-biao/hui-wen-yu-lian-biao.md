\#\# 判断是否回文链表



回文的定义是从左往右和从右往左读是一样的。



\#\#\# 方法1：利用栈



思路：



1. 先遍历一遍链表，一一把节点值加入栈中。

2. 再遍历一次节点，和弹出的栈顶值比较，如果都相同，则是回文的。



空间：O\(N\)，时间O\(2\*N\)=O\(N\)



\#\#\# 方法2：利用栈+对称



思路：



1. 先遍历一遍链表，得到链表大小N。

2. 再遍历一遍链表，把前N/2个值放入栈中。

3. 如果N为奇数，则跳过中间这个。

4. 然后把弹出的栈顶值和接着遍历链表的值比较。



空间：O\(N/2\)=O\(N\)，时间O\(2\*N\)=O\(N\)



\#\#\# 方法3：双指针+逆序后半边链表



思路：



1. 快慢两个指针，慢指针q每次走一步，快指针p每次走两步。



   1. 如果N是奇数，则p走到终点时，q走到第N/2+1个点（正中间）。

   2. 如果N是偶数，则p走到倒数第二个点时，q在N/2的位置（中间偏左），接下来p再走一步到终点。



   \`\`\`

   p=q=head;

   while\(p.next!=null&&p.next.next!=null\){

   	q=q.next;

   	p=p.next.next;

   }

   if\(p.next!=null\){

   	p=p.next;

   }

   \`\`\`



   



2. 



2. 逆转后半段链表。需要3个指针。代码如下：



   \`\`\`java

   cur=q;

   nxt=cur.next;

   //注意后半段的起点变终点，需要把它的next置位空

   q.next=null;

   while\(nxt!=null\){

       nnxt=nxt.next;

       //逆转关系

       nxt.next=cur;

       //向下走

       cur=nxt;

       nxt=nnxt;

   }

   \`\`\`



   



3. 比较前半段和逆转的后半段，直到n1走到p（正中间或者中间偏左）为止。



时间：O\(N\)，空间O\(1\)



\#\# 判断链表是否有环及环起点



\#\#\# 方法1：利用set



遍历链表，加入set，如果当前的点已经在set中，则说明有环。



\#\#\# 方法2：利用快慢指针



1. 快指针p走两步，慢指针q走一步。



2. 如果快指针p走到空，则说明无环。

3. 当p、q相遇时，p走回到起点，并改为每次走一步。

4. 第二次相遇即是环的起点



证明：第二次相遇时是在环的起点。



如图，假设：环入口距离起始点距离为a，第一次相遇在距离环入口距离x处，环的大小为b。







第一次相遇时，存在$m\_1$和$n\_1$，使得：



$$\begin{align}

t\_1 &= a+m\_1\*b+x \\

2\*t\_1 &= a+n\_1\*b+x  \\

2\*\(a+m\_1\*b+x\) &= a+n\_1\*b+x \\

a+x &= \(n\_1-2\*m\_1\)\*b

\end{align}$$



需要证明第二次相遇时是在环的起点。也就是需要证明存在m\_2和n\_2:



$$\begin{align}

a+m\_2\*b &= b-x+n\_2\*b \\

a+x &= \(n\_2-m\_2\)\*b \\

\(n\_1-2\*m\_1\)\*b &= \(n\_2-m\_2\)\*b \\

\(n\_1-2\*m\_1\) &= \(n\_2-m\_2\)

\end{align}$$



自然存在满足条件的$m\_1$、$n\_1$、$m\_2$、$n\_2$，满足上式，所以得证。



时间复杂度：O\(N+A\)，空间O\(1\)

