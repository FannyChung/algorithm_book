# 链表

\#\# 判断是否回文链表

回文的定义是从左往右和从右往左读是一样的。

\#\#\# 方法1：利用栈

思路：

1. 先遍历一遍链表，一一把节点值加入栈中。

2. 再遍历一次节点，和弹出的栈顶值比较，如果都相同，则是回文的。

空间：O\(N\)，时间O\(2\*N\)=O\(N\)

\#\#\# 方法2：利用栈+对称

思路：

1. 先遍历一遍链表，得到链表大小N。

2. 再遍历一遍链表，把前N/2个值放入栈中。

3. 如果N为奇数，则跳过中间这个。

4. 然后把弹出的栈顶值和接着遍历链表的值比较。

空间：O\(N/2\)=O\(N\)，时间O\(2\*N\)=O\(N\)

\#\#\# 方法3：双指针+逆序后半边链表

思路：

1. 快慢两个指针，慢指针q每次走一步，快指针p每次走两步。

1. 如果N是奇数，则p走到终点时，q走到第N/2+1个点（正中间）。

2. 如果N是偶数，则p走到倒数第二个点时，q在N/2的位置（中间偏左），接下来p再走一步到终点。

\`\`\`

p=q=head;

while\(p.next!=null&&p.next.next!=null\){

```
   q=q.next;

   p=p.next.next;
```

}

if\(p.next!=null\){

```
   p=p.next;
```

}

\`\`\`



1. 逆转后半段链表。需要3个指针。代码如下：

\`\`\`java

cur=q;

nxt=cur.next;

//注意后半段的起点变终点，需要把它的next置位空

q.next=null;

while\(nxt!=null\){

```
   nnxt=nxt.next;

   //逆转关系

   nxt.next=cur;

   //向下走

   cur=nxt;

   nxt=nnxt;
```

}

\`\`\`

1. 比较前半段和逆转的后半段，直到n1走到p（正中间或者中间偏左）为止。

时间：O\(N\)，空间O\(1\)

\#\# 判断链表是否有环及环起点

\#\#\# 方法1：利用set

遍历链表，加入set，如果当前的点已经在set中，则说明有环。

\#\#\# 方法2：利用快慢指针

1. 快指针p走两步，慢指针q走一步。

1. 如果快指针p走到空，则说明无环。

2. 当p、q相遇时，p走回到起点，并改为每次走一步。

3. 第二次相遇即是环的起点

证明：第二次相遇时是在环的起点。

如图，假设：环入口距离起始点距离为a，第一次相遇在距离环入口距离x处，环的大小为b。

第一次相遇时，存在$m\_1$和$n\_1$，使得：

$$\begin{align}

t\_1 &= a+m\_1\*b+x \

2\*t\_1 &= a+n\_1\*b+x  \

2\*\(a+m\_1\*b+x\) &= a+n\_1\*b+x \

a+x &= \(n\_1-2\*m\_1\)\*b

\end{align}$$

需要证明第二次相遇时是在环的起点。也就是需要证明存在m\_2和n\_2:

$$\begin{align}

a+m\_2\*b &= b-x+n\_2\*b \

a+x &= \(n\_2-m\_2\)\*b \

\(n\_1-2\*m\_1\)\*b &= \(n\_2-m\_2\)\*b \

\(n\_1-2\*m\_1\) &= \(n\_2-m\_2\)

\end{align}$$

自然存在满足条件的$m\_1$、$n\_1$、$m\_2$、$n\_2$，满足上式，所以得证。

时间复杂度：O\(N+A\)，空间O\(1\)

