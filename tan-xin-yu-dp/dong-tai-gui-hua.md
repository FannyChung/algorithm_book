# 动态规划

## 矩阵中的最小路径和

二维矩阵，只能向下或者向右，求最小路径和。

### 递归

f\(x,y\)

//两种选择，向下或者向右

f\(x+1,y\)+A\[x,y\]

f\(x,y+1\)+A\[x,y\]

出口（实现时放在最前）：

* 到终点：返回A\[x,y\]
* 到最后一行（只能向右）：f\(x,y+1\)+A\[x,y\]
* 到最后一列（只能向下）：f\(x+1,y\)+A\[x,y\]

存在问题：重复计算，比如f\(0,1\)和f\(1,0\)都需要计算f\(1,1\)

### DP

从递归函数中找到可变参数：x和y，以它们为坐标建立矩阵。

对应出口情况：

* 矩阵右下角：A\[x,y\]
* 矩阵最后一行：从右向左填充，为右侧点的计算值+当前点的值。
* 矩阵最后一列：从下向上填充。

dp\[x,y\]=

* 如果是终点：A\[x,y\]
* 如果是最后一行：dp\[x,y+1\]+A\[x,y\]
* 如果是最后一列 :dp\[x+1,y\]+A\[x,y\]
* 其他：min{dp\[x+1,y\],dp\[x,y+1\]}+A\[x,y\]



## 选择指定和的元素

数组arr中选择元素，使得和为k。

每个元素可以选择，可以不选择。

### 递归

f\(i,sum\)

出口：

i==N 返回sum==k

非出口：

f\(i+1,sum\)\|\|f\(i+1,sum+arr\[i\]\)

O\(2^N\)

### DP

可变参数为i和sum

初始：dp\[N,k\]=true;dp\[N,其他值\]=false;

dp\[i,sum\]=dp\[i+1,sum\]\|\|dp\[i+1,sum+arr\[i\]\]

返回dp\[0,0\]



## 最大和划分子数组

划分的连续子数组的最大长度K，划分后，子数组的每个值为子数组里的最大值。求新数组的最大和。

dp\[i\]代表考虑了\[0,i\]的所有元素的最大和。

dp\[i\]=for all k 选最大 dp\[i-k\]+max\*k

其中max=Max{max,A\[i - k + 1\]}，k可以从1~K，当然k还要&lt;=i+1.

